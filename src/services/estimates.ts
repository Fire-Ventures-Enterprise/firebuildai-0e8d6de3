import { supabase } from "@/integrations/supabase/client";

interface EstimateFormData {
  customer_id: string;
  job_id?: string;
  issue_date?: string;
  expiration_date?: string;
  scope_of_work?: string;
  deposit_amount?: number;
  deposit_percentage?: number;
  notes?: string;
  terms_conditions?: string;
  contract_attached?: boolean;
  items: Array<{
    description: string;
    quantity: number;
    rate: number;
  }>;
}

export const EstimatesService = {
  async list(searchQuery?: string) {
    let query = supabase
      .from("estimates")
      .select(`
        *,
        customer:customers(*)
      `)
      .order("created_at", { ascending: false });

    if (searchQuery) {
      query = query.or(`estimate_number.ilike.%${searchQuery}%,notes.ilike.%${searchQuery}%`);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data ?? [];
  },

  async get(id: string) {
    const { data, error } = await supabase
      .from("estimates")
      .select(`
        *,
        items:estimate_items(*),
        customer:customers(*)
      `)
      .eq("id", id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      throw error;
    }
    return data;
  },

  async create(formData: EstimateFormData) {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("No authenticated user");

    // Calculate totals
    const subtotal = formData.items.reduce((sum, item) => sum + (item.quantity * item.rate), 0);
    const taxAmount = subtotal * 0.13;
    const total = subtotal + taxAmount;

    const { data: estimate, error } = await supabase
      .from("estimates")
      .insert({
        user_id: user.id,
        customer_id: formData.customer_id,
        status: "draft",
        issue_date: formData.issue_date || new Date().toISOString().split('T')[0],
        expiration_date: formData.expiration_date,
        subtotal,
        tax_rate: 13,
        tax_amount: taxAmount,
        total,
        deposit_amount: formData.deposit_amount,
        deposit_percentage: formData.deposit_percentage,
        notes: formData.notes,
        terms_conditions: formData.terms_conditions,
        scope_of_work: formData.scope_of_work,
        contract_attached: formData.contract_attached ?? true,
        estimate_number: '', // Will be auto-generated by trigger
      })
      .select("*")
      .single();

    if (error) throw error;

    // Add items
    if (formData.items?.length) {
      const items = formData.items.map((item, index) => ({
        estimate_id: estimate.id,
        description: item.description,
        quantity: item.quantity,
        rate: item.rate,
        amount: item.quantity * item.rate,
        sort_order: index,
      }));
      
      const { error: itemsError } = await supabase
        .from("estimate_items")
        .insert(items);
      
      if (itemsError) throw itemsError;
    }

    return this.get(estimate.id);
  },

  async update(id: string, formData: Partial<EstimateFormData>) {
    const { error } = await supabase
      .from("estimates")
      .update({
        customer_id: formData.customer_id,
        expiration_date: formData.expiration_date,
        notes: formData.notes,
        terms_conditions: formData.terms_conditions,
        scope_of_work: formData.scope_of_work,
        deposit_amount: formData.deposit_amount,
        deposit_percentage: formData.deposit_percentage,
      })
      .eq("id", id);

    if (error) throw error;

    // Update items if provided
    if (formData.items) {
      // Delete existing items
      await supabase
        .from("estimate_items")
        .delete()
        .eq("estimate_id", id);

      // Add new items
      const subtotal = formData.items.reduce((sum, item) => sum + (item.quantity * item.rate), 0);
      const taxAmount = subtotal * 0.13;
      const total = subtotal + taxAmount;

      const items = formData.items.map((item, index) => ({
        estimate_id: id,
        description: item.description,
        quantity: item.quantity,
        rate: item.rate,
        amount: item.quantity * item.rate,
        sort_order: index,
      }));
      
      await supabase.from("estimate_items").insert(items);
      
      // Update totals
      await supabase
        .from("estimates")
        .update({ subtotal, tax_amount: taxAmount, total })
        .eq("id", id);
    }

    return this.get(id);
  },

  async delete(id: string) {
    const { error } = await supabase
      .from("estimates")
      .delete()
      .eq("id", id);
    if (error) throw error;
  },

  async updateStatus(id: string, status: string) {
    const { data, error } = await supabase
      .from("estimates")
      .update({ status })
      .eq("id", id)
      .select("*")
      .single();
    if (error) throw error;
    return data;
  },

  async convertToInvoice(estimateId: string) {
    const estimate = await this.get(estimateId);
    if (!estimate) throw new Error("Estimate not found");

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("No authenticated user");

    // Create invoice from estimate
    const { data: invoice, error } = await supabase
      .from("invoices_enhanced")
      .insert({
        user_id: user.id,
        customer_id: estimate.customer_id,
        issue_date: new Date().toISOString().split('T')[0],
        due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        subtotal: estimate.subtotal,
        tax_rate: estimate.tax_rate,
        tax_amount: estimate.tax_amount,
        total: estimate.total,
        deposit_amount: estimate.deposit_amount,
        notes: estimate.notes,
        status: "draft",
        invoice_number: '', // Will be auto-generated
        po_number: `EST-${estimate.estimate_number}`, // Reference to estimate
      })
      .select("*")
      .single();

    if (error) throw error;

    // Copy items to invoice
    if (estimate.items?.length) {
      const items = estimate.items.map((item: any) => ({
        invoice_id: invoice.id,
        item_name: item.description,
        description: item.description,
        quantity: item.quantity,
        rate: item.rate,
        amount: item.amount,
        tax: true,
        sort_order: item.sort_order,
      }));
      
      await supabase.from("invoice_items_enhanced").insert(items);
    }

    // Mark estimate as converted
    await supabase
      .from("estimates")
      .update({ converted_to_invoice: true, invoice_id: invoice.id })
      .eq("id", estimateId);

    return invoice;
  }
};